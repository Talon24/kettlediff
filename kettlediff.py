#!/usr/bin/python
"""Module to normalize .ktr and .kjb files.

When using PDI, it is possible for certain XML tags (like hops and steps) that
their order in the .ktr/.kjb file changes which can obfuscate the git diff.
This module shall order the elements of the XML that are potentially altered
so that the diff only shows actual changes rather than moved XML blocks.

This module can also be used for .prpt files from Pentaho Report Designer.

Instructions to use this module with git:

Add the following to "~/.gitconfig":
[diff "kettle"]
    textconv = python /path/to/this/kettlediff.py
    xfuncname = <name>(.*)</name>|<order>|<hops>
[diff "prpt"]
    textconv = python /path/to/this/kettlediff.py
    xfuncname = .*name=.*
[diff "xlsx"]
    textconv = python /path/to/this/kettlediff.py
    xfuncname = Sheet:.*


To set a global attributes file for your user rather than editing
the attributes for all of your projects, also add the path to that file
to the .gitconfig, e.g.:
[core]
    attributesfile = ~/.gitattributes

At that attributes file or the projects attributes file, add the following:
*.ktr diff=kettle
*.kjb diff=kettle
*.prpt diff=prpt
*.xlsx diff=xlsx

"""

from __future__ import print_function

import io
import re
import os
import sys
import html
import difflib
import pathlib
import zipfile
import argparse
from xml.dom import minidom
from functools import partial

# if "lxml" in sys.modules:
try:
    import lxml.etree as ET
except ImportError:
    import xml.etree.ElementTree as ET

try:
    import colorama
    colorama.init(convert=True)
except ImportError:
    pass

__author__ = "Talon24"
__license__ = "MIT"
__version__ = "1.0.1"
__maintainer__ = "Talon24"
__email__ = "talontalon24@googlemail.com"
__status__ = "Production"

SEP = "\n"
# os.linesep might be useful, but in default settings git will protest


def caseless(my_input):
    """Use .casefold() if python3, fallback to .lower() if python2.
    Also casts the function input to string."""
    if sys.version_info >= (3, 3):  # pylint: disable=no-else-return
        return str(my_input).casefold()
    else:
        return str(my_input).lower()


def xml_element_key(element):
    """Use for sorting tree elements, use the name content if ambiguous."""
    multiples = ("connection", "step", "entries")
    if element.tag in multiples:  # pylint: disable=no-else-return
        return "■" + caseless(element.tag) + caseless(element[0].text)
        # box (■) is a late ascii char to sort these Elements on end
        # Also unlikely to be included in node names and therefore edge names
    else:
        return caseless(element.tag)


def hop_key(hop):
    """Generate name for hops."""
    text = hop.find("from").text + " ■ ■ " + hop.find("to").text
    return caseless(text)


def hop_element_idx(lst):
    """Search through xml, find index of Element with tag 'order' or 'hops'."""
    for idx, element in enumerate(lst):
        if element.tag == "order" or element.tag == "hops":
            return idx
    return None


def data_cleaning(data, mode):
    """Fixing known differences in input files that are caused by differing
    versions of pdi but don't result in functional changing of the file."""
    # return data
    data = html.unescape(data)
    if mode == "PDI":
        # Issue: Changing whitespaces on empty tags
        data = re.sub(r"<([^>]*)>\r?\n?\s*</\1>", r"<\1> </\1>", data)

        # Issue: Some fields may be set to default values?
        #        Remove value if default
        data = re.sub(r"(<field>[\r\n\s]*<name>.*</name>)[\r\n\s]*"
                      r"<rename/>[\r\n\s]*"
                      r"<length>-2</length>[\r\n\s]*<precision>-2</precision>",
                      r"\1", data)
        data = re.sub(r"(</case_sensitive>)\r?\n\s*"
                      r"<collator_enabled>N</collator_enabled>"
                      r"\r?\n\s*<collator_strength>2</collator_strength>"
                      r"(\r?\n\s*<presorted>)", r"\1\2", data)
        data = re.sub(r"(</output_file_field>)\r?\n\s*<create_parent_folder>N"
                      r"</create_parent_folder>(\r?\n\s*<parameters>)",
                      r"\1\2", data)
        data = re.sub(r"(</logging_remote_work>|</pass_export>)\r?\n\s*"
                      r"<run_configuration/>(\r?\n\s*<parameters>)",
                      r"\1\2", data)
    elif mode == "PRD":
        # Issue: empty style:element-style-like tags disappearing in version
        data = re.sub(r"^(.*?):\s*<(?:style:)?(element-style)>\r?\n"
                      r"\1:\s*</(?:style:)?\2>\r?\n",
                      r"", data, re.MULTILINE)
    else:
        pass

    return data


def kettlediff(path, no_visuals=False):
    """Parse XML file generated by Pentaho Data Integration.
    Returns sorted XML file to stdout."""
    xmltree = ET.parse(str(path)).getroot()
    title = xmltree.tag
    old = list(xmltree)

    # Find the hop element, sort the hops and insert the sorted hops back in
    hops_idx = hop_element_idx(old)  # Get index of Element that contains edges
    if hops_idx is not None:  # Sort sublist of hops and write back into list
        hops = sorted(old[hops_idx], key=hop_key)
        hop_element = ET.Element(old[hops_idx].tag)  # Make empty edges Element
        for element in hops:
            hop_element.append(element)  # Insert edges in correct order
        old[hops_idx] = hop_element  # Replace edges Element

    old.sort(key=xml_element_key)  # Sort first level by tag or by <name>-field

    new = ET.Element(title)  # Make head Element
    for element in old:
        new.append(element)  # Insert Elements in correct order

    if no_visuals:
        pairs = []
        for parent in new.iter():
            for child in parent.findall("xloc"):
                pairs.append((parent, child))
            for child in parent.findall("yloc"):
                pairs.append((parent, child))
        for parent, child in pairs:
            parent.remove(child)

        for notepad in new.findall("notepads/notpad"):
            notepad.remove(notepad.find("width"))
            notepad.remove(notepad.find("height"))

    # Cast Element Tree to string
    xml = ET.tostring(new, encoding="utf-8", method="xml")
    xml = minidom.parseString(xml).toprettyxml(indent=" " * 4, newl=SEP)

    # Remove empty lines
    result = "".join([line for line in xml.splitlines(True) if line.strip()])

    return data_cleaning(result, "PDI")


def prddiff(path):
    """Textify the .prpt files from Pentaho Report Designer
        and return to stdout.
    Mimes the behaviour of:                    zipgrep -e '*'
    That will probably be faster, but this way zipgrep does not
    need to be installed (possibly requires root access)."""
    with open(path, "rb") as file:  # Minimize time file is accessed
        data = io.BytesIO(file.read())
    result = []
    with zipfile.ZipFile(data, 'r') as zipref:  # Unzip
        for file in zipref.namelist():  # Path of all files in archive
            if file.endswith("/"):  # Skip folders
                continue
            try:
                for fileline in zipref.open(file):
                    result.append("%s: %s" % (file, fileline.decode(
                        sys.stdout.encoding, "backslashreplace")))
            except UnicodeDecodeError:
                result.append("%s: >> Binary File <<" % (file))
    return data_cleaning("".join(result), "PRD")


# def xlsxdiff(path):
#     """Open Excel file and iterate through all the cells in all the rows.
#
#     Uses openpyxl, open with zip would need to ignore cahches etc.
#     Slow, apparently can't handle large files well, additional dependency,
#     therefore own implementation below."""
#     import openpyxl
#     size = os.stat(path).st_size
#     if size > 1 * 1024 ** 2:
#         print("%.3f MB" % (os.stat(path).st_size / 1024 ** 2))
#         return "Too Large"
#     result = []  # To avoid continuous printing
#     workbook = openpyxl.load_workbook(path)
#     for sheetname in workbook.sheetnames:
#         sheet = workbook[sheetname]
#         result.append("\nSheet: %s\n" % sheetname)
#         for row in sheet.iter_rows():
#             result.append("Row: %s\n" % row[0].row)
#             for cell in row:
#                 out = "[%s]: %s\n" % (cell.coordinate, cell.value)
#                 result.append(out)
#     return "".join(result)


def xlsxdiff2(path):
    """Parse xlsx file using the zip module."""
    def analyze_row(row, result):
        """Go through all cells in a row and append result."""
        result.append("--Row")
        # result.append("--Row [%s]" % re.search(
        #     r"(\d+)", row.get("r")[0]).group(1))
        for cell in row:
            try:
                pos = cell.get("r")
                if cell.get("t") == "s":
                    val = strings[int(list(cell.itertext())[0])]
                else:
                    val = list(cell.itertext())[0]
                target_format = "y"  # Command line argument goes here
                insert_options = {
                    "x": re.search(r"(\d+)$", pos).group(1),
                    "y": re.search(r"^(\D+)", pos).group(1),
                    "e": "  ", "": "  ", "xy": pos, "val": val}
                prepared_output = "[%%(%s)s]: %%(val)s" % target_format
                result.append(prepared_output % insert_options)
            except IndexError:
                pass  # Nothing in cell
            except ValueError:
                print(list(cell.itertext())[0])
                print(cell.keys())
                print(cell.get("s"))
                sys.exit()

    result = []
    size = os.stat(path).st_size
    if size > 1 * 1024 ** 2:
        print("%.3f MB" % (os.stat(path).st_size / 1024 ** 2))
        return "Too Large"
    with zipfile.ZipFile(path, 'r') as zipref:  # Unzip

        tree = ET.fromstring(zipref.open("xl/sharedStrings.xml").read())
        strings = [i[0].text for i in tree]

        tree = ET.fromstring(zipref.open("xl/workbook.xml").read())
        sheets = [i for i in tree if i.tag.endswith("sheets")][0]
        titles = {i.attrib["sheetId"]: i.attrib["name"] for i in sheets}

        for file in zipref.namelist():  # Path of all files in archive
            if file.startswith("xl/worksheets") and file.endswith("xml"):
                result.append("------ Sheet: %s" % (
                    titles[re.search(r"sheet(\d+)", file).group(1)]))
                tree = ET.fromstring(zipref.open(file).read())
                tree = tree[4]
                rows = list(tree)
                for row in rows:
                    analyze_row(row, result)
    return "\n".join(result)


def colordiff(conversion1, conversion2,
              path1=None, path2=None, show_all=False):
    """Can be used as replacement for git diff if necessary. To be used if no
       git is available, e.g. when used with subversion."""
    def colorline(line):
        """color the lines if possible"""
        if "colorama" in sys.modules:
            if line.startswith(" "):  # No Change
                return line
            if line.startswith("+"):  # Added
                return colorama.Fore.GREEN + line + colorama.Style.RESET_ALL
            if line.startswith("-"):  # Removed
                return colorama.Fore.RED + line + colorama.Style.RESET_ALL
            if line.startswith("@"):  # Header
                return colorama.Fore.CYAN + line + colorama.Style.RESET_ALL
        return line
    number = 3 if not show_all else 10 ** 4

    lines = [colorline(line) for line in difflib.unified_diff(
        conversion1.splitlines(),
        conversion2.splitlines(),
        fromfile=str(path1), tofile=str(path2), n=number)]
    return SEP.join(lines)


def main():
    """Decide how to handle the input file."""
    parser = argparse.ArgumentParser(
        description="Convert file to text to pass it to git diff. If git diff "
        "is not available, a second file can be specified to simulate "
        "git diff's output.")
    parser.add_argument("path", help="Path of the file that should get "
                        "converted to text.", type=pathlib.Path)
    parser.add_argument("path2", nargs="?", help="Path of second file to "
                        "compare with the first file.", type=pathlib.Path)
    parser.add_argument(
        "-m", "--mode", default=None, choices=["xlsx", "prpt", "ktr", "kjb"],
        help="Use a specific conversion method, "
        "overturning automatic file ending based selection.")
    parser.add_argument("-s", "--show-all", action="store_true", help=""
                        "Show the complete diff.")
    parser.add_argument("-v", "--version", action='version',
                        version='%%(prog)s %s' % __version__)
    parser.add_argument("--no-visuals", action="store_true", help=""
                        "Don't show changes in the PDI visuals.")
    # parser.add_argument("--excel-coordinate", default="c",
    #                     choices=["r", "c", "b", "row", "column", "both"])
    arguments = parser.parse_args()
    functions = {"ktr": partial(kettlediff, no_visuals=arguments.no_visuals),
                 "kjb": partial(kettlediff, no_visuals=arguments.no_visuals),
                 "prpt": prddiff,
                 "xlsx": xlsxdiff2}
    path = arguments.path
    path2 = arguments.path2
    if arguments.mode is None:
        function = functions.get(path.suffix.lower()[1:], None)
    else:
        function = functions.get(arguments.mode, None)
    if function is None:
        raise IOError("This program does not support files with this "
                      "extension. Consider specifying the converting "
                      "method if you think this is wrong.")
    if arguments.path2 is None:  # pylint: disable=no-else-return
        return function(path)
    else:
        return colordiff(function(path), function(path2),
                         path, path2, show_all=arguments.show_all)


if __name__ == '__main__':
    print(main())
    # cProfile.run("main()")
